package net.earthcomputer.clientcommands;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Predicate;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import net.earthcomputer.clientcommands.task.LongTask;
import net.earthcomputer.clientcommands.task.TaskManager;
import net.minecraft.advancements.AdvancementProgress;
import net.minecraft.block.material.Material;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.gui.GuiEnchantment;
import net.minecraft.enchantment.Enchantment;
import net.minecraft.enchantment.EnchantmentData;
import net.minecraft.enchantment.EnchantmentHelper;
import net.minecraft.entity.EntityLiving;
import net.minecraft.entity.EnumCreatureAttribute;
import net.minecraft.entity.item.EntityItem;
import net.minecraft.entity.item.EntityXPOrb;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Blocks;
import net.minecraft.init.Enchantments;
import net.minecraft.init.Items;
import net.minecraft.inventory.ClickType;
import net.minecraft.inventory.Container;
import net.minecraft.inventory.ContainerEnchantment;
import net.minecraft.inventory.Slot;
import net.minecraft.item.EnumAction;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketChatMessage;
import net.minecraft.network.play.client.CPacketEnchantItem;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketAdvancementInfo;
import net.minecraft.network.play.server.SPacketEntityStatus;
import net.minecraft.network.play.server.SPacketWindowProperty;
import net.minecraft.util.IStringSerializable;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.util.text.TextFormatting;
import net.minecraft.world.World;
import net.minecraftforge.common.ForgeHooks;
import net.minecraftforge.event.ForgeEventFactory;
import net.minecraftforge.fml.relauncher.ReflectionHelper;

public class EnchantmentCracker {

	/*
	 * The enchantment cracker works as follows:
	 * 
	 * First, crack the first few XP seeds. When you open an enchantment table GUI,
	 * the server gives you 12 bits of the 32-bit enchantment seed. Vanilla uses
	 * this masked version of the seed to generate the galactic alphabet text in the
	 * GUI. We use brute force to guess the other 20 bits, matching each possibility
	 * and what it would generate with certain things the server tells us, such as
	 * the enchantment hints. We can narrow down the possibilities to 1 after
	 * putting a few items into the enchantment table.
	 * 
	 * Second, we know that the above XP seeds are generated by calling the player
	 * entity's RNG's unbounded nextInt() method. This means that after a doing the
	 * above a few times, enchanting an item after each time, we have a few
	 * consecutive values of nextInt(). Each time an item is enchanted, we narrow
	 * down the possibilities of what the player RNG's state could be. The first
	 * value of nextInt() gives us 32 bits of its 48-bit internal state. Each time
	 * nextInt() is next called, we narrow down its internal state by brute force.
	 * It usually only takes two values of nextInt() to guess the internal state.
	 * 
	 * There's one small catch: for this to work, we have to know that the values of
	 * nextInt() are indeed consecutive. The first XP seed, if it's cracked, cannot
	 * be used as one of these values since it was generated an unknown length of
	 * time in the past, possibly even before a server restart - so we have to
	 * ignore that. More obviously, there are many, many other things which use the
	 * player's RNG and hence affect its internal state. We have to detect on the
	 * client side when one of these things is likely to be happening. This is only
	 * possible to do for certain if the server is running vanilla because some mod
	 * could use the player's RNG for some miscellaneous task.
	 * 
	 * Third, we can take advantage of the fact that generating XP seeds is not the
	 * only thing that the player RNG does, to manipulate the RNG to produce an XP
	 * seed which we want. The /cenchant command, which calls the
	 * manipulateEnchantments method of this class, does this. We change the state
	 * of the player RNG in a predictable way by throwing out items of the player's
	 * inventory. Each time the player throws out an item, rand.nextFloat() gets
	 * called 4 times to determine the velocity of the item which is thrown out. If
	 * we throw out n items before we then do a dummy enchantment to generate our
	 * new enchantment seed, then we can change n to change the enchantment seed. By
	 * simulating which XP seed each n (up to a limit) will generate, and which
	 * enchantments that XP seed will generate, we can filter out which enchantments
	 * we want and determine n.
	 */

	private static final Logger LOGGER = LogManager.getLogger(ClientCommandsMod.MODID);

	public static void registerEvents() {
		registerRNGCheckEvents();
		registerRenderingEvents();
		registerLogicEvents();
	}

	// RNG CHECK
	/*
	 * The RNG check tries to detect client-side every single case where the
	 * player's RNG could be called server side. The only known case (other than a
	 * modded server) where this doesn't work is currently when a server operator
	 * other than you gives you an item with the /give command. This is deemed
	 * undetectable on the client-side.
	 */

	private static boolean wasWet = false;
	private static int expectedThrows = 0;

	private static void registerRNGCheckEvents() {
		EventManager.addLivingAttackListener(e -> {
			if (isEnchantingPredictionEnabled()) {
				if (e.getEntity() == Minecraft.getMinecraft().player) {
					resetCracker("player hurt");
				}
			}
		});
		EventManager.addPlayerTickListener(e -> {
			if (isEnchantingPredictionEnabled()) {
				EntityPlayer player = e.player;
				if (player.isSprinting()) {
					resetCracker("sprinting");
				}
				if (player.isWet() && !wasWet) {
					resetCracker("entered water");
				}
				if (player.isWet() && (!player.isSneaking() || !player.onGround)) {
					resetCracker("swimming");
				}
				if (!player.getActivePotionEffects().isEmpty()) {
					resetCracker("potion effect active");
				}
				if (!EnchantmentHelper.getEnchantedItem(Enchantments.MENDING, player).isEmpty() && !player.world
						.getEntitiesWithinAABB(EntityXPOrb.class, player.getEntityBoundingBox()).isEmpty()) {
					resetCracker("mending item");
				}
				if (player.isInsideOfMaterial(Material.WATER) && EnchantmentHelper.getRespirationModifier(player) > 0) {
					resetCracker("using respiration");
				}
				if (EnchantmentHelper.hasFrostWalkerEnchantment(player)) {
					frostWalkerCheck(player,
							EnchantmentHelper.getMaxEnchantmentLevel(Enchantments.FROST_WALKER, player));
				}
				wasWet = player.isWet();
			}
		});
		EventManager.addEntitySpawnListener(e -> {
			if (isEnchantingPredictionEnabled()) {
				if (e.getEntity() instanceof EntityItem && e.getEntity().getEntityBoundingBox()
						.intersects(Minecraft.getMinecraft().player.getEntityBoundingBox())) {
					if (expectedThrows == 0) {
						resetCracker("drop item");
					} else {
						expectedThrows--;
					}
				}
			}
		});
		EventManager.addAnvilRepairListener(e -> {
			if (isEnchantingPredictionEnabled()) {
				resetCracker("anvil use");
			}
		});
		EventManager.addUseItemListener(e -> {
			if (isEnchantingPredictionEnabled()) {
				ItemStack stack = e.getItemStack();
				if (stack.isEmpty()) {
					return;
				}

				if (e.getItemStack().getItemUseAction() == EnumAction.EAT) {
					resetCracker("eating");
				}
			}
		});
		EventManager.addAttackEntityListener(e -> {
			if (isEnchantingPredictionEnabled()) {
				ItemStack heldStack = e.getEntityPlayer().getHeldItemMainhand();
				if (!heldStack.isEmpty()) {
					if (e.getTarget() instanceof EntityLiving && ((EntityLiving) e.getTarget())
							.getCreatureAttribute() == EnumCreatureAttribute.ARTHROPOD) {
						if (EnchantmentHelper.getEnchantments(heldStack).containsKey(Enchantments.BANE_OF_ARTHROPODS)) {
							// The player's RNG is used to determine whether the slowness effect should be
							// applied
							resetCracker("bane of arthropods");
						}
					}
				}
			}
		});
		EventManager.addInboundPacketPreListener(e -> {
			if (isEnchantingPredictionEnabled()) {
				Packet<?> packet = e.getPacket();
				if (packet instanceof SPacketAdvancementInfo) {
					SPacketAdvancementInfo advancementInfo = (SPacketAdvancementInfo) packet;
					if (!advancementInfo.isFirstSync() && advancementInfo.getProgressUpdates().values().stream()
							.anyMatch(AdvancementProgress::isDone)) {
						resetCracker("gain advancement");
					}
				} else if (packet instanceof SPacketEntityStatus) {
					SPacketEntityStatus entityStatus = (SPacketEntityStatus) packet;
					if (entityStatus.getOpCode() == 29) { // 29 = play shield block sound effect
						if (entityStatus.getEntity(Minecraft.getMinecraft().world) == Minecraft.getMinecraft().player) {
							resetCracker("blocking with shield");
						}
					}
				}
			}
		});
		EventManager.addOutboundPacketPreListener(e -> {
			if (isEnchantingPredictionEnabled()) {
				Packet<?> packet = e.getPacket();
				if (packet instanceof CPacketChatMessage) {
					CPacketChatMessage chat = (CPacketChatMessage) packet;
					String message = chat.getMessage();
					if (message.startsWith("/") && message.substring(1).trim().startsWith("give")) {
						resetCracker("give command");
					}
				}
			}
		});
		EventManager.addPostDamageItemListener(e -> {
			ItemStack heldStack = e.getItemStack();
			if (EnchantmentHelper.getEnchantments(heldStack).containsKey(Enchantments.UNBREAKING)) {
				resetCracker("unbreaking item");
			} else if (heldStack.getItemDamage() + e.getDamageAmount() > heldStack.getMaxDamage() + 1) {
				resetCracker("broke item");
			}
		});
	}

	private static void frostWalkerCheck(EntityPlayer player, int level) {
		World world = player.world;
		BlockPos pos = new BlockPos(player);

		// see EnchantmentFrostWalker.freezeNearby

		if (player.onGround) {
			float radius = (float) Math.min(16, 2 + level);
			BlockPos.MutableBlockPos posAboveWater = new BlockPos.MutableBlockPos(0, 0, 0);

			for (BlockPos.MutableBlockPos waterPos : BlockPos.getAllInBoxMutable(pos.add(-radius, -1, -radius),
					pos.add(radius, -1, radius))) {
				if (waterPos.distanceSqToCenter(player.posX, player.posY, player.posZ) <= radius * radius) {
					posAboveWater.setPos(waterPos.getX(), waterPos.getY() + 1, waterPos.getZ());
					IBlockState stateAboveWater = world.getBlockState(posAboveWater);

					if (stateAboveWater.getMaterial() == Material.AIR) {
						IBlockState stateAtWater = world.getBlockState(waterPos);

						if (stateAtWater.getBlock() == Blocks.FROSTED_ICE) {
							resetCracker("frost walking");
							return;
						}
					}
				}
			}
		}
	}

	public static void resetCracker(String reason) {
		if (TempRules.ENCHANTING_CRACK_STATE.getValue() != EnumCrackState.UNCRACKED) {
			Minecraft.getMinecraft().ingameGUI.getChatGUI().printChatMessage(
					new TextComponentString(TextFormatting.RED + "Restarting enchantment cracking. Reason: " + reason));
		}
		resetCracker();
	}

	// RENDERING
	/*
	 * This section is in charge of rendering the overlay on the enchantment GUI
	 */

	private static void registerRenderingEvents() {
		EventManager.addGuiOverlayListener(e -> {
			if (isEnchantingPredictionEnabled()) {
				if (e.getGui() instanceof GuiEnchantment) {
					drawEnchantmentGUIOverlay();
				}
			}
		});
	}

	private static void drawEnchantmentGUIOverlay() {
		EnumCrackState crackState = TempRules.ENCHANTING_CRACK_STATE.getValue();

		List<String> lines = new ArrayList<>();

		lines.add("Crack state: " + crackState.getName());

		lines.add("");

		if (crackState == EnumCrackState.CRACKED_ENCH_SEED) {
			lines.add("XP seed: " + String.format("%08X", possibleXPSeeds.iterator().next()));
		} else if (crackState == EnumCrackState.CRACKING_ENCH_SEED) {
			lines.add("Possible XP seeds: " + possibleXPSeeds.size());
		} else if (crackState == EnumCrackState.CRACKING && !possiblePlayerRandSeeds.isEmpty()) {
			lines.add("Possible player RNG seeds: " + possiblePlayerRandSeeds.size());
		}

		lines.add("");

		if (crackState == EnumCrackState.CRACKED || crackState == EnumCrackState.CRACKED_ENCH_SEED) {
			lines.add("Enchantments:");
		} else {
			lines.add("Clues:");
		}

		for (int slot = 0; slot < 3; slot++) {
			lines.add("Slot " + (slot + 1) + ":");
			List<EnchantmentData> enchs = getEnchantmentsInTable(slot);
			if (enchs != null) {
				for (EnchantmentData ench : enchs) {
					lines.add("   " + ench.enchantment.getTranslatedName(ench.enchantmentLevel));
				}
			}
		}

		FontRenderer fontRenderer = Minecraft.getMinecraft().fontRenderer;
		int y = 0;
		for (String line : lines) {
			fontRenderer.drawString(line, 0, y, 0xffffff);
			y += fontRenderer.FONT_HEIGHT;
		}
	}

	// LOGIC
	/*
	 * This section is in charge of the logic of the cracking
	 */

	private static final long MULTIPLIER = 0x5deece66dL;
	private static final long ADDEND = 0xbL;
	private static final long MASK = (1L << 48) - 1;

	private static Set<Integer> possibleXPSeeds = new HashSet<>(1 << 20);
	private static boolean onFirstXPSeed = true;
	private static int windowPropertyUpdatesUntilXPSeedUpdate = -1;
	private static Set<Long> possiblePlayerRandSeeds = new HashSet<>(1 << 16);
	private static Random playerRand = new Random();
	private static boolean doneEnchantment = false;

	private static void registerLogicEvents() {
		TempRules.ENCHANTING_PREDICTION.addValueChangeListener(e -> {
			if (!e.getNewValue()) {
				resetCracker();
			}
		});
		EventManager.addInboundPacketPreListener(e -> {
			if (isEnchantingPredictionEnabled()) {
				// When the fields of the enchantment container change, we need to do stuff with
				// the new information. We wait until we have cycled over all 10 fields without
				// them changing again before we do anything with the new information. We can do
				// this because the server repeatedly sends this packet even if the value
				// doesn't change.
				Packet<?> packet = e.getPacket();
				if (packet instanceof SPacketWindowProperty) {
					SPacketWindowProperty windowProp = (SPacketWindowProperty) packet;
					Minecraft mc = Minecraft.getMinecraft();

					Container container = mc.player.openContainer;
					if (container instanceof ContainerEnchantment && windowProp.getWindowId() == container.windowId) {
						ContainerEnchantment enchContainer = (ContainerEnchantment) container;

						// Get the previous value of the field
						int currentValue;
						if (windowProp.getProperty() < 3) {
							currentValue = enchContainer.enchantLevels[windowProp.getProperty()];
						} else if (windowProp.getProperty() == 3) {
							currentValue = enchContainer.xpSeed;
						} else if (windowProp.getProperty() < 7) {
							currentValue = enchContainer.enchantClue[windowProp.getProperty() - 4];
						} else {
							currentValue = enchContainer.worldClue[windowProp.getProperty() - 7];
						}

						if (windowProp.getValue() != currentValue) {
							// do it in 10 packets' time
							windowPropertyUpdatesUntilXPSeedUpdate = 10;
						} else if (windowPropertyUpdatesUntilXPSeedUpdate >= 0) {
							// decrement counter, do it if time is up
							windowPropertyUpdatesUntilXPSeedUpdate--;
							if (windowPropertyUpdatesUntilXPSeedUpdate == 0) {
								// try to get the table position (ContainerEnchantment.position is null on the
								// client)
								BlockPos tablePos = null;
								if (mc.objectMouseOver.typeOfHit == RayTraceResult.Type.BLOCK) {
									if (mc.world.getBlockState(mc.objectMouseOver.getBlockPos())
											.getBlock() == Blocks.ENCHANTING_TABLE) {
										tablePos = mc.objectMouseOver.getBlockPos();
									}
								}
								// if the table position is null, do it
								if (tablePos != null) {
									addEnchantmentSeedInfo(mc.world, tablePos, enchContainer);
								}
							}
						}
					}
				}
			}
		});
		EventManager.addOutboundPacketPreListener(e -> {
			if (isEnchantingPredictionEnabled()) {
				Packet<?> packet = e.getPacket();
				if (packet instanceof CPacketEnchantItem) {
					onEnchantedItem();
					doneEnchantment = true;
				}
			}
		});
	}

	public static void resetCracker() {
		TempRules.ENCHANTING_CRACK_STATE.setValue(EnumCrackState.UNCRACKED);
		onFirstXPSeed = true;
		possibleXPSeeds.clear();
		possiblePlayerRandSeeds.clear();
	}

	private static void prepareForNextEnchantmentSeedCrack(int serverReportedXPSeed) {
		serverReportedXPSeed &= 0x0000fff0;
		for (int highBits = 0; highBits < 65536; highBits++) {
			for (int low4Bits = 0; low4Bits < 16; low4Bits++) {
				possibleXPSeeds.add((highBits << 16) | serverReportedXPSeed | low4Bits);
			}
		}
	}

	private static void addEnchantmentSeedInfo(World world, BlockPos tablePos, ContainerEnchantment container) {
		EnumCrackState crackState = TempRules.ENCHANTING_CRACK_STATE.getValue();
		if (crackState == EnumCrackState.CRACKED_ENCH_SEED || crackState == EnumCrackState.CRACKED) {
			return;
		}

		ItemStack itemToEnchant = container.tableInventory.getStackInSlot(0);
		if (itemToEnchant.isEmpty() || !itemToEnchant.isItemEnchantable()) {
			return;
		}

		if (crackState == EnumCrackState.UNCRACKED || crackState == EnumCrackState.CRACKING) {
			TempRules.ENCHANTING_CRACK_STATE.setValue(EnumCrackState.CRACKING_ENCH_SEED);
			prepareForNextEnchantmentSeedCrack(container.xpSeed);
		}
		int power = getEnchantPower(world, tablePos);

		Random rand = new Random();
		int[] actualEnchantLevels = container.enchantLevels;
		int[] actualEnchantmentClues = container.enchantClue;
		int[] actualLevelClues = container.worldClue;

		// brute force the possible seeds
		Iterator<Integer> xpSeedItr = possibleXPSeeds.iterator();
		seedLoop: while (xpSeedItr.hasNext()) {
			int xpSeed = xpSeedItr.next();
			rand.setSeed(xpSeed);

			// check enchantment levels match
			for (int slot = 0; slot < 3; slot++) {
				int level = EnchantmentHelper.calcItemStackEnchantability(rand, slot, power, itemToEnchant);
				if (level < slot + 1) {
					level = 0;
				}
				level = ForgeEventFactory.onEnchantmentLevelSet(world, tablePos, slot, power, itemToEnchant, level);
				if (level != actualEnchantLevels[slot]) {
					xpSeedItr.remove();
					continue seedLoop;
				}
			}

			// generate enchantment clues and see if they match
			for (int slot = 0; slot < 3; slot++) {
				if (actualEnchantLevels[slot] > 0) {
					List<EnchantmentData> enchantments = getEnchantmentList(rand, xpSeed, itemToEnchant, slot,
							actualEnchantLevels[slot]);
					if (enchantments == null || enchantments.isEmpty()) {
						// check that there is indeed no enchantment clue
						if (actualEnchantmentClues[slot] != -1 || actualLevelClues[slot] != -1) {
							xpSeedItr.remove();
							continue seedLoop;
						}
					} else {
						// check the right enchantment clue was generated
						EnchantmentData clue = enchantments.get(rand.nextInt(enchantments.size()));
						if (Enchantment.getEnchantmentID(clue.enchantment) != actualEnchantmentClues[slot]
								|| clue.enchantmentLevel != actualLevelClues[slot]) {
							xpSeedItr.remove();
							continue seedLoop;
						}
					}
				}
			}
		}

		// test the outcome, see if we need to change state
		if (possibleXPSeeds.size() == 0) {
			TempRules.ENCHANTING_CRACK_STATE.setValue(EnumCrackState.INVALID);
			LOGGER.warn(
					"Invalid enchantment seed information. Has the server got unknown mods, is there a desync, or is the client just bugged?");
		} else if (possibleXPSeeds.size() == 1) {
			TempRules.ENCHANTING_CRACK_STATE.setValue(EnumCrackState.CRACKED_ENCH_SEED);
			if (!onFirstXPSeed) {
				addPlayerRNGInfo(possibleXPSeeds.iterator().next());
			}
			onFirstXPSeed = false;
		}
	}

	private static void addPlayerRNGInfo(int enchantmentSeed) {
		EnumCrackState crackState = TempRules.ENCHANTING_CRACK_STATE.getValue();
		if (crackState == EnumCrackState.CRACKED) {
			return;
		}

		long newSeedHigh = ((long) enchantmentSeed << 16) & 0x0000_ffff_ffff_0000L;
		if (possiblePlayerRandSeeds.isEmpty() && crackState != EnumCrackState.INVALID) {
			// add initial 2^16 possibilities
			for (int lowBits = 0; lowBits < 65536; lowBits++) {
				possiblePlayerRandSeeds.add(newSeedHigh | lowBits);
			}
		} else {
			// it's okay to allocate a new one, it will likely be small anyway
			Set<Long> newPlayerRandSeeds = new HashSet<>();
			// narrow down possibilities using brute force
			for (long oldSeed : possiblePlayerRandSeeds) {
				// this is what Random.nextInt() does internally
				long newSeed = (oldSeed * MULTIPLIER + ADDEND) & MASK;
				if ((newSeed & 0x0000_ffff_ffff_0000L) == newSeedHigh) {
					newPlayerRandSeeds.add(newSeed);
				}
			}
			// add the new seed, not the old one, since the state of the RNG has changed
			// server-side
			possiblePlayerRandSeeds.clear();
			possiblePlayerRandSeeds.addAll(newPlayerRandSeeds);

			// check the outcome, see if we need to change state
			if (possiblePlayerRandSeeds.size() == 0) {
				TempRules.ENCHANTING_CRACK_STATE.setValue(EnumCrackState.INVALID);
				LOGGER.warn(
						"Invalid player RNG information. Has the server got unknown mods, is there a desync, has an operator used /give, or is the client just bugged?");
			} else if (possiblePlayerRandSeeds.size() == 1) {
				TempRules.ENCHANTING_CRACK_STATE.setValue(EnumCrackState.CRACKED);
				playerRand.setSeed(possiblePlayerRandSeeds.iterator().next() ^ MULTIPLIER);
				possiblePlayerRandSeeds.clear();
			}
		}
	}

	public static void onEnchantedItem() {
		EnumCrackState crackState = TempRules.ENCHANTING_CRACK_STATE.getValue();
		if (crackState == EnumCrackState.CRACKED) {
			possibleXPSeeds.clear();
			possibleXPSeeds.add(playerRand.nextInt());
		} else if (crackState == EnumCrackState.CRACKED_ENCH_SEED) {
			possibleXPSeeds.clear();
			TempRules.ENCHANTING_CRACK_STATE.setValue(EnumCrackState.CRACKING);
		} else {
			resetCracker();
			onFirstXPSeed = false;
		}
	}

	// ENCHANTMENT MANIPULATION
	/*
	 * This section is involved in actually manipulating the enchantments and the XP
	 * seed
	 */

	private static EnchantManipulationStatus manipulateEnchantmentsSanityCheck(EntityPlayer player) {
		if (TempRules.ENCHANTING_CRACK_STATE.getValue() != EnumCrackState.CRACKED) {
			return EnchantManipulationStatus.NOT_CRACKED;
		} else if (!player.onGround) {
			return EnchantManipulationStatus.NOT_ON_GROUND;
		} else if (player.inventoryContainer.getInventory().stream().allMatch(ItemStack::isEmpty)) {
			return EnchantManipulationStatus.EMPTY_INVENTORY;
		} else {
			return EnchantManipulationStatus.OK;
		}
	}

	public static EnchantManipulationStatus manipulateEnchantments(Item item,
			Predicate<List<EnchantmentData>> enchantmentsPredicate) {
		EntityPlayerSP player = Minecraft.getMinecraft().player;

		EnchantManipulationStatus status = manipulateEnchantmentsSanityCheck(player);
		if (status != EnchantManipulationStatus.OK) {
			return status;
		}

		ItemStack stack = new ItemStack(item);
		long seed = ReflectionHelper.<AtomicLong, Random>getPrivateValue(Random.class, playerRand, "seed").get();
		// -2: not found; -1: no dummy enchantment needed; >= 0: number of times needed
		// to throw out item before dummy enchantment
		int timesNeeded = -2;
		int bookshelvesNeeded = 0;
		int slot = 0;
		int[] enchantLevels = new int[3];
		outerLoop: for (int i = -1; i < 1000; i++) {
			int xpSeed = (int) ((i == -1 ? seed : ((seed * MULTIPLIER + ADDEND) & MASK)) >>> 16);
			Random rand = new Random();
			for (bookshelvesNeeded = 0; bookshelvesNeeded <= 15; bookshelvesNeeded++) {
				rand.setSeed(xpSeed);
				for (slot = 0; slot < 3; slot++) {
					int level = EnchantmentHelper.calcItemStackEnchantability(rand, slot, bookshelvesNeeded, stack);
					if (level < slot + 1) {
						level = 0;
					}
					enchantLevels[slot] = level;
				}
				for (slot = 0; slot < 3; slot++) {
					List<EnchantmentData> enchantments = getEnchantmentList(rand, xpSeed, stack, slot,
							enchantLevels[slot]);
					if (enchantmentsPredicate.test(enchantments)) {
						timesNeeded = i;
						break outerLoop;
					}
				}
			}

			if (i != -1) {
				for (int j = 0; j < 4; j++) {
					seed = (seed * MULTIPLIER + ADDEND) & MASK;
				}
			}
		}
		if (timesNeeded == -2) {
			return EnchantManipulationStatus.IMPOSSIBLE;
		}

		if (timesNeeded != -1) {
			if (timesNeeded != 0) {
				player.setLocationAndAngles(player.posX, player.posY, player.posZ, player.rotationYaw, 90);
				// sync rotation to server before we throw any items
				player.connection.sendPacket(new CPacketPlayer.Rotation(player.rotationYaw, 90, player.onGround));
			}
			for (int i = 0; i < timesNeeded; i++) {
				// throw the item
				TaskManager.addLongTask(new LongTask() {
					private boolean firstTick = true;

					@Override
					protected void taskTick() {
						if (firstTick) {
							EnchantManipulationStatus status = manipulateEnchantmentsSanityCheck(player);
							if (status != EnchantManipulationStatus.OK) {
								if (status != EnchantManipulationStatus.EMPTY_INVENTORY) {
									player.sendMessage(
											new TextComponentString(TextFormatting.RED + status.getMessage()));
									TaskManager.abortTasks();
									return;
								}
							}
							Slot matchingSlot = player.inventoryContainer.inventorySlots.stream()
									.filter(Slot::getHasStack).findAny().orElse(null);
							if (matchingSlot == null) {
								return;
							}
							expectedThrows++;
							for (int i = 0; i < 4; i++) {
								playerRand.nextInt();
							}
							Minecraft.getMinecraft().playerController.windowClick(player.inventoryContainer.windowId,
									matchingSlot.slotNumber, 0, ClickType.THROW, player);
							firstTick = false;
						} else {
							setFinished();
						}
					}
				});
			}
			// dummy enchantment
			TaskManager.addLongTask(new LongTask() {
				@Override
				public void start() {
					player.sendMessage(new TextComponentString("Do a dummy enchantment"));
					doneEnchantment = false;
				}

				@Override
				protected void taskTick() {
					if (doneEnchantment) {
						setFinished();
					}
				}

				@Override
				protected int getTimeout() {
					return Integer.MAX_VALUE;
				}
			});
		}
		final int bookshelvesNeeded_f = bookshelvesNeeded;
		final int slot_f = slot;
		TaskManager.addLongTask(new LongTask() {
			@Override
			public void start() {
				player.sendMessage(new TextComponentString(TextFormatting.BOLD + "Your enchantment seed is ready"));
				player.sendMessage(new TextComponentString("Bookshelves needed: " + bookshelvesNeeded_f));
				player.sendMessage(new TextComponentString("In slot: " + (slot_f + 1)));
				setFinished();
			}

			@Override
			protected void taskTick() {
			}
		});

		return EnchantManipulationStatus.OK;
	}

	public static enum EnchantManipulationStatus {
		// @formatter:off
		OK(null),
		NOT_CRACKED("You need to be in crack state CRACKED"),
		NOT_ON_GROUND("You are not on the ground"),
		EMPTY_INVENTORY("You have an empty inventory"),
		IMPOSSIBLE("It's impossible or would take too long to get those enchantments");
		// @formatter:on

		private String message;

		private EnchantManipulationStatus(String message) {
			this.message = message;
		}

		public String getMessage() {
			return message;
		}
	}

	// MISCELLANEOUS HELPER METHODS & ENCHANTING SIMULATION

	private static boolean isEnchantingPredictionEnabled() {
		return TempRules.ENCHANTING_PREDICTION.getValue();
	}

	private static int getEnchantPower(World world, BlockPos tablePos) {
		float power = 0;

		for (int dz = -1; dz <= 1; dz++) {
			for (int dx = -1; dx <= 1; dx++) {
				if ((dz != 0 || dx != 0) && world.isAirBlock(tablePos.add(dx, 0, dz))
						&& world.isAirBlock(tablePos.add(dx, 1, dz))) {
					power += ForgeHooks.getEnchantPower(world, tablePos.add(dx * 2, 0, dz * 2));
					power += ForgeHooks.getEnchantPower(world, tablePos.add(dx * 2, 1, dz * 2));
					if (dx != 0 && dz != 0) {
						power += ForgeHooks.getEnchantPower(world, tablePos.add(dx * 2, 0, dz));
						power += ForgeHooks.getEnchantPower(world, tablePos.add(dx * 2, 1, dz));
						power += ForgeHooks.getEnchantPower(world, tablePos.add(dx, 0, dz * 2));
						power += ForgeHooks.getEnchantPower(world, tablePos.add(dx, 1, dz * 2));
					}
				}
			}
		}

		return (int) power;
	}

	private static List<EnchantmentData> getEnchantmentList(Random rand, int xpSeed, ItemStack stack, int enchantSlot,
			int level) {
		rand.setSeed(xpSeed + enchantSlot);
		List<EnchantmentData> list = EnchantmentHelper.buildEnchantmentList(rand, stack, level, false);

		if (stack.getItem() == Items.BOOK && list.size() > 1) {
			list.remove(rand.nextInt(list.size()));
		}

		return list;
	}

	// Same as above method, except does not assume the seed has been cracked. If it
	// hasn't returns the clue given by the server
	public static List<EnchantmentData> getEnchantmentsInTable(int slot) {
		EnumCrackState crackState = TempRules.ENCHANTING_CRACK_STATE.getValue();
		ContainerEnchantment enchContainer = (ContainerEnchantment) Minecraft.getMinecraft().player.openContainer;

		if (crackState != EnumCrackState.CRACKED_ENCH_SEED && crackState != EnumCrackState.CRACKED) {
			if (enchContainer.enchantClue[slot] == -1) {
				// if we haven't cracked it, and there's no clue, then we can't give any
				// information about the enchantment
				return null;
			} else {
				// return a list containing the clue
				return Collections.singletonList(
						new EnchantmentData(Enchantment.getEnchantmentByID(enchContainer.enchantClue[slot]),
								enchContainer.worldClue[slot]));
			}
		} else {
			// return the enchantments using our cracked seed
			Random rand = new Random();
			int xpSeed = possibleXPSeeds.iterator().next();
			ItemStack enchantingStack = enchContainer.tableInventory.getStackInSlot(0);
			int enchantLevels = enchContainer.enchantLevels[slot];
			return getEnchantmentList(rand, xpSeed, enchantingStack, slot, enchantLevels);
		}
	}

	public static enum EnumCrackState implements IStringSerializable {
		UNCRACKED, CRACKING_ENCH_SEED, CRACKED_ENCH_SEED, CRACKING, CRACKED, INVALID;

		@Override
		public String getName() {
			return name();
		}
	}

}
