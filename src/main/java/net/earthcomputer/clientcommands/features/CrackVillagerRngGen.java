package net.earthcomputer.clientcommands.features;

import com.seedfinding.latticg.math.component.BigMatrix;
import com.seedfinding.latticg.math.component.BigVector;
import com.seedfinding.latticg.math.lattice.enumerate.EnumerateRt;
import com.seedfinding.latticg.math.optimize.Optimize;
import com.seedfinding.latticg.util.DeserializeRt;
import java.util.stream.LongStream;

// CLASS GENERATED BY LATTICG, DO NOT EDIT MANUALLY
public final class CrackVillagerRngGen {
    private CrackVillagerRngGen() {}
    private static final BigMatrix BASIS = DeserializeRt.mat(
        "Ȃ苻봇˃\uf1afᄂ\udaf8찄˦鋃ᜂ");
    private static final BigMatrix ROOT_INV = DeserializeRt.mat(
        "Ȃ\ue692쌗肀肀肀老싱꼑肀肀肀老\udbf8찄肀肀肀老苻봇肀肀肀老");
    private static final BigVector ORIGIN = DeserializeRt.vec(
        "ȀȖȀ");
    private static final BigVector ROOT_ORIGIN = DeserializeRt.vec(
        "˖\ue08e뼁肀肀肀老雉ꥒ肀肀肀老");

    /**
     * Finds all values of {@code seed} that could produce the given results in the following code:
     * <pre>{@code
     *    Random rand = new Random(seed ^ 0x5DEECE66DL);
     *    // Go backwards by 2 random calls
     *    long nextLong1 = rand.nextLong();
     * }</pre>
     *
     * <p>This code skips 0.000000% of seeds in its search.
     */
    public static LongStream getSeeds(long nextLong1) {
        Optimize.Builder builder = Optimize.Builder.ofSize(2);
        long longFirstSeed1 = nextLong1 >>> 32 << 16;
        if (nextLong1 < 0) {
            longFirstSeed1 += (1L << 16);
        }
        builder.withLowerBound(0, longFirstSeed1).withUpperBound(0, longFirstSeed1 + (1L << 16) - 1);
        builder.withLowerBound(1, (nextLong1 & 0xffffffffL) << 16).withUpperBound(1, (((nextLong1 & 0xffffffffL) + 1) << 16) - 1);
        return EnumerateRt.enumerate(BASIS, ORIGIN, builder.build(), ROOT_INV, ROOT_ORIGIN)
            .mapToLong(vec -> (vec.get(0).getNumerator().longValue() * 0x5deece66dL + 0xbL) & ((1L << 48) - 1));
    }
}
